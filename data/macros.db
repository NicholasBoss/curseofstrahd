{"name":"Charm Person","type":"script","author":"0Dxn79T2d0e5V3LW","img":"icons/magic/life/heart-shadow-red.webp","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Charm Person\")","folder":null,"sort":0,"permission":{"default":0,"0Dxn79T2d0e5V3LW":3},"flags":{"dnd5e":{"itemMacro":true}},"_id":"0iuP1pME30pb92sh"}
{"name":"True Strike","type":"script","author":"NuvjPNM22yeczDUW","img":"systems/dnd5e/icons/spells/enchant-eerie-2.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"True Strike\")","folder":null,"sort":0,"permission":{"default":0,"NuvjPNM22yeczDUW":3},"flags":{"dnd5e":{"itemMacro":true},"scene-packer":{"hash":"6cea76ea76349e3ffb1e5418dba01d1fef5bd4a4"}},"_id":"3sKZ565Kywj8qPjX"}
{"name":"Frost Brand Greatsword","type":"script","author":"n8QOlEn7xXUrcdjh","img":"icons/skills/melee/strike-weapon-polearm-ice-blue.webp","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Frost Brand Greatsword\")","folder":null,"sort":0,"permission":{"default":0,"n8QOlEn7xXUrcdjh":3},"flags":{"dnd5e":{"itemMacro":true},"scene-packer":{"hash":"583ebd07e4118556a8f30438ebe7cf5127dd942b"}},"_id":"FFWQjrjG3LjJVPie"}
{"name":"New Macro","type":"chat","author":"NuvjPNM22yeczDUW","img":"icons/svg/dice-target.svg","scope":"global","command":"","folder":null,"sort":0,"permission":{"default":0,"NuvjPNM22yeczDUW":3},"flags":{},"_id":"Fi6lXboTyEI7UzBx"}
{"name":"Hellish Rebuke","type":"script","author":"NuvjPNM22yeczDUW","img":"systems/dnd5e/icons/spells/horror-red-1.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Hellish Rebuke\")","folder":null,"sort":0,"permission":{"default":0,"NuvjPNM22yeczDUW":3},"flags":{"dnd5e":{"itemMacro":true},"scene-packer":{"hash":"37f9c815a1037acbdcef8d4430a3f0aebe8538dc"}},"_id":"JRD97L4Ev3VgfXAX"}
{"_id":"JrgPDES3M4upNXy1","name":"Active Aura Damage On Entry (Generic)","type":"script","author":"oU9dS4x0FAP6KDBX","img":"icons/svg/dice-target.svg","scope":"global","command":"if(!game.modules.get(\"ActiveAuras\")?.active) {\n  ui.notifications.error(\"ActiveAuras is not enabled\");\n  return;\n}\n\nconst lastArg = args[args.length - 1];\n\nfunction getCantripDice(actor) {\n  const level = actor.type === \"character\" ? actor.data.details.level : actor.data.details.cr;\n  return 1 + Math.floor((level + 1) / 6);\n}\n\nasync function rollItemDamage(targetToken, itemUuid, itemLevel) {\n  const item = await fromUuid(itemUuid);\n  const caster = item.parent;\n  const ddbEffectFlags = item.data.flags.ddbimporter.effect;\n  const isCantrip = ddbEffectFlags.isCantrip;\n  const damageDice = ddbEffectFlags.dice;\n  const damageType = ddbEffectFlags.damageType;\n  const saveAbility = ddbEffectFlags.save;\n  const casterToken = canvas.tokens.placeables.find((t) => t.actor?.uuid === caster.uuid);\n  const scalingDiceArray = item.data.data.scaling.formula.split(\"d\");\n  const scalingDiceNumber = itemLevel - item.data.data.level;\n  const upscaledDamage =  isCantrip\n    ? `${getCantripDice(caster.data)}d${scalingDiceArray[1]}[${damageType}]`\n    : scalingDiceNumber > 0 ? `${scalingDiceNumber}d${scalingDiceArray[1]}[${damageType}] + ${damageDice}` : damageDice;\n\n  const workflowItemData = duplicate(item.data);\n  workflowItemData.data.target = { value: 1, units: \"\", type: \"creature\" };\n  workflowItemData.data.save.ability = saveAbility;\n  workflowItemData.data.components.concentration = false;\n  workflowItemData.data.level = itemLevel;\n  workflowItemData.data.duration = { value: null, units: \"inst\" };\n  workflowItemData.data.target = { value: null, width: null, units: \"\", type: \"creature\" };\n\n  setProperty(workflowItemData, \"flags.itemacro\", {});\n  setProperty(workflowItemData, \"flags.midi-qol\", {});\n  setProperty(workflowItemData, \"flags.dae\", {});\n  setProperty(workflowItemData, \"effects\", []);\n  delete workflowItemData._id;\n\n  const saveOnEntry = ddbEffectFlags.saveOnEntry;\n  console.warn(\"saveOnEntry\", {ddbEffectFlags, saveOnEntry});\n  if (saveOnEntry) {\n    const entryItem = new CONFIG.Item.documentClass(workflowItemData, { parent: caster });\n    console.warn(\"Saving item on entry\", {entryItem, targetToken});\n    const options = {\n      showFullCard: false,\n      createWorkflow: true,\n      targetUuids: [targetToken.document.uuid],\n      configureDialog: false,\n      versatile: false,\n      consumeResource: false,\n      consumeSlot: false,\n    };\n    await MidiQOL.completeItemRoll(entryItem, options);\n  } else {\n    const damageRoll = await new Roll(upscaledDamage).evaluate({ async: true });\n    if (game.dice3d) game.dice3d.showForRoll(damageRoll);\n\n    workflowItemData.name = `${workflowItemData.name}: Turn Entry Damage`;\n    // console.warn(\"workflowItemData\", workflowItemData);\n\n    await new MidiQOL.DamageOnlyWorkflow(\n      caster,\n      casterToken.data,\n      damageRoll.total,\n      damageType,\n      [targetToken],\n      damageRoll,\n      {\n        flavor: `(${CONFIG.DND5E.damageTypes[damageType]})`,\n        itemCardId: \"new\",\n        itemData: workflowItemData,\n        isCritical: false,\n      }\n    );\n  }\n\n}\n\nasync function attachSequencerFileToTemplate(templateUuid, sequencerFile, originUuid) {\n  if (game.modules.get(\"sequencer\")?.active) {\n    if (Sequencer.Database.entryExists(sequencerFile)) {\n      console.debug(\"Trying to apply sequencer effect\", sequencerFile);\n      const template = await fromUuid(templateUuid);\n      new Sequence()\n      .effect()\n        .file(Sequencer.Database.entryExists(sequencerFile))\n        .size({\n          width: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n          height: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n        })\n        .persist(true)\n        .origin(originUuid)\n        .belowTokens()\n        .opacity(0.5)\n        .attachTo(template, { followRotation: true })\n        .stretchTo(template, { attachTo: true})\n      .play();\n    }\n  }\n}\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preActiveEffects\") {\n  const safeName = lastArg.itemData.name.replace(/\\s|'|\\.|’/g, \"_\");\n  const dataTracker = {\n    randomId: randomID(),\n    targetUuids: lastArg.targetUuids,\n    startRound: game.combat.round,\n    startTurn: game.combat.turn,\n    spellLevel: lastArg.spellLevel,\n  };\n\n  const item = await fromUuid(lastArg.itemUuid);\n  // await item.update(dataTracker);\n  await DAE.unsetFlag(item, `${safeName}Tracker`);\n  await DAE.setFlag(item, `${safeName}Tracker`, dataTracker);\n\n  const ddbEffectFlags = lastArg.item.flags.ddbimporter?.effect;\n  const newArgs = duplicate(args);\n  if (ddbEffectFlags) {\n    const sequencerFile = ddbEffectFlags.sequencerFile;\n    if (sequencerFile) {\n      attachSequencerFileToTemplate(lastArg.templateUuid, sequencerFile, lastArg.itemUuid)\n    }\n    if (ddbEffectFlags.isCantrip) {\n      const cantripDice = getCantripDice(lastArg.actor);\n      newArgs[0].spellLevel = cantripDice;\n      ddbEffectFlags.cantripDice = cantripDice;\n      let newEffects = newArgs[0].item.effects.map((effect) => {\n        effect.changes = effect.changes.map((change) => {\n          change.value = change.value.replace(\"@cantripDice\", cantripDice)\n          return change;\n        });\n        return effect;\n      });\n      newArgs[0].item.effects = duplicate(newEffects);\n      newArgs[0].itemData.effects = duplicate(newEffects);\n    }\n    const template = await fromUuid(lastArg.templateUuid);\n    await template.update({\"flags.effect\": ddbEffectFlags});\n  }\n\n  return await AAhelpers.applyTemplate(newArgs);\n\n} else if (args[0] == \"on\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const item = await fromUuid(lastArg.efData.origin);\n  const targetItemTracker = DAE.getFlag(item.parent, `${safeName}Tracker`);\n  const originalTarget = targetItemTracker.targetUuids.includes(lastArg.tokenUuid);\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTrackerFlag = DAE.getFlag(target, `${safeName}Tracker`);\n  const targetedThisCombat = targetTokenTrackerFlag && targetItemTracker.randomId === targetTokenTrackerFlag.randomId;\n  const targetTokenTracker = targetedThisCombat\n    ? targetTokenTrackerFlag\n    : {\n      randomId: targetItemTracker.randomId,\n      round: game.combat.round,\n      turn: game.combat.turn,\n      hasLeft: false,\n    };\n\n  const castTurn = targetItemTracker.startRound === game.combat.round && targetItemTracker.startTurn === game.combat.turn;\n  const isLaterTurn = game.combat.round > targetTokenTracker.round || game.combat.turn > targetTokenTracker.turn;\n\n  // if:\n  // not cast turn, and not part of the original target\n  // AND one of the following\n  // not original template and have not yet had this effect applied this combat OR\n  // has been targeted this combat, left and re-entered effect, and is a later turn\n  if (castTurn && originalTarget) {\n    console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n  } else if (!targetedThisCombat || (targetedThisCombat && targetTokenTracker.hasLeft && isLaterTurn)){\n    console.debug(`Token ${target.name} is targeted for immediate damage with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n    targetTokenTracker.hasLeft = false;\n    await rollItemDamage(target, lastArg.efData.origin, targetItemTracker.spellLevel);\n  }\n  await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n} else if (args[0] == \"off\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTracker = DAE.getFlag(target, `${safeName}Tracker`);\n\n  if (targetTokenTracker) {\n    targetTokenTracker.hasLeft = true;\n    targetTokenTracker.turn = game.combat.turn;\n    targetTokenTracker.round = game.combat.round;\n    await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n  }\n}","folder":"lAtOjIPqjbuyD4E3","sort":0,"permission":{"default":0,"oU9dS4x0FAP6KDBX":3},"flags":{"advanced-macros":{"runAsGM":false}}}
{"_id":"Omugh63MEFeVxKV1","name":"Active Aura Only (Generic)","type":"script","author":"oU9dS4x0FAP6KDBX","img":"icons/svg/dice-target.svg","scope":"global","command":"if(!game.modules.get(\"ActiveAuras\")?.active) {\n  ui.notifications.error(\"ActiveAuras is not enabled\");\n  return;\n}\n\nconst lastArg = args[args.length - 1];\n\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n\nasync function attemptRemoval(targetToken, condition, item) {\n  if (game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    new Dialog({\n      title: `Use action to attempt to remove ${condition}?`,\n      buttons: {\n        one: {\n          label: \"Yes\",\n          callback: async () => {\n            const caster = item.parent;\n            const saveDc = caster.data.data.attributes.spelldc;\n            const removalCheck = item.data.flags.ddbimporter.effect.removalCheck;\n            const removalSave = item.data.flags.ddbimporter.effect.removalSave;\n            const ability = removalCheck ? removalCheck : removalSave;\n            const type = removalCheck ? \"check\" : \"save\";\n            const flavor = `${condition} (via ${item.name}) : ${CONFIG.DND5E.abilities[ability]} ${type} vs DC${saveDc}`;\n            const rollResult = removalCheck\n              ? (await targetToken.actor.rollAbilityTest(ability, { flavor })).total\n              : (await targetToken.actor.rollAbilitySave(ability, { flavor })).total;\n\n            if (rollResult >= saveDc) {\n              game.dfreds.effectInterface.removeEffect({ effectName: condition, uuid: targetToken.document.uuid });\n            } else {\n              if (rollResult < saveDc) ChatMessage.create({ content: `${targetToken.name} fails the ${type} for ${item.name}, still has the ${condition} condition.` });\n            }\n          },\n        },\n        two: {\n          label: \"No\",\n          callback: () => {},\n        },\n      },\n    }).render(true);\n  }\n}\n\nasync function applyCondition(condition, targetToken, item, itemLevel) {\n  if (!game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    const caster = item.parent;\n    const workflowItemData = duplicate(item.data);\n    workflowItemData.data.target = { value: 1, units: \"\", type: \"creature\" };\n    workflowItemData.data.save.ability = item.data.flags.ddbimporter.effect.save;\n    workflowItemData.data.components.concentration = false;\n    workflowItemData.data.level = itemLevel;\n    workflowItemData.data.duration = { value: null, units: \"inst\" };\n    workflowItemData.data.target = { value: null, width: null, units: \"\", type: \"creature\" };\n    workflowItemData.data.preparation.mode = \"atwill\";\n    setProperty(workflowItemData, \"flags.itemacro\", {});\n    setProperty(workflowItemData, \"flags.midi-qol\", {});\n    setProperty(workflowItemData, \"flags.dae\", {});\n    setProperty(workflowItemData, \"effects\", []);\n    delete workflowItemData._id;\n    workflowItemData.name = `${workflowItemData.name}: ${item.name} Condition save`;\n    // console.warn(\"workflowItemData\", workflowItemData);\n\n    const saveTargets = [...game.user?.targets].map((t )=> t.id);\n    game.user.updateTokenTargets([targetToken.id]);\n    const saveItem = new CONFIG.Item.documentClass(workflowItemData, { parent: caster });\n    const options = { showFullCard: false, createWorkflow: true, configureDialog: true };\n    const result = await MidiQOL.completeItemRoll(saveItem, options);\n\n    game.user.updateTokenTargets(saveTargets);\n    const failedSaves = [...result.failedSaves];\n    if (failedSaves.length > 0) {\n      await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: failedSaves[0].document.uuid });\n    }\n\n    return result;\n  }\n}\n\nasync function attachSequencerFileToTemplate(templateUuid, sequencerFile, originUuid) {\n  if (game.modules.get(\"sequencer\")?.active) {\n    if (Sequencer.Database.entryExists(sequencerFile)) {\n      console.debug(`Trying to apply sequencer effect (${sequencerFile}) to ${templateUuid} from ${originUuid}`, sequencerFile);\n      const template = await fromUuid(templateUuid);\n      new Sequence()\n      .effect()\n        .file(Sequencer.Database.entryExists(sequencerFile))\n        .size({\n          width: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n          height: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n        })\n        .persist(true)\n        .origin(originUuid)\n        .belowTokens()\n        .opacity(0.5)\n        .attachTo(template, { followRotation: true })\n        .stretchTo(template, { attachTo: true})\n      .play();\n    }\n  }\n}\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preActiveEffects\") {\n  const safeName = lastArg.itemData.name.replace(/\\s|'|\\.|’/g, \"_\");\n  const dataTracker = {\n    randomId: randomID(),\n    targetUuids: lastArg.targetUuids,\n    startRound: game.combat.round,\n    startTurn: game.combat.turn,\n    spellLevel: lastArg.spellLevel,\n  };\n\n  const item = await fromUuid(lastArg.itemUuid);\n  // await item.update(dataTracker);\n  await DAE.unsetFlag(item, `${safeName}Tracker`);\n  await DAE.setFlag(item, `${safeName}Tracker`, dataTracker);\n\n  const sequencerFile = lastArg.item.flags.ddbimporter?.effect?.sequencerFile;\n  if (sequencerFile) {\n    attachSequencerFileToTemplate(lastArg.templateUuid, sequencerFile, lastArg.itemUuid)\n  }\n\n  if (lastArg.item.flags.ddbimporter?.effect?.applyImmediate) {\n    await wait(500);\n    const condition = lastArg.item.flags.ddbimporter.effect.condition;\n    for (const token of lastArg.failedSaves) {\n      if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n        console.debug(`Applying ${condition} to ${token.name}`);\n        await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n      }\n    };\n  }\n\n  return await AAhelpers.applyTemplate(args);\n\n} else if (args[0].tag === \"OnUse\" && args[0].macroPass === \"postActiveEffects\") {\n  if (lastArg.item.flags.ddbimporter?.effect?.applyImmediate) {\n    const condition = lastArg.item.flags.ddbimporter.effect.condition;\n    for (const token of lastArg.failedSaves) {\n      if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n        console.debug(`Applying ${condition} to ${token.name}`);\n        await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n      }\n    };\n  }\n} else if (args[0] == \"on\" || args[0] == \"each\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const item = await fromUuid(lastArg.efData.origin);\n  // sometimes the round info has not updated, so we pause a bit\n  if (args[0] == \"each\") await wait(500);\n  const targetItemTracker = DAE.getFlag(item.parent, `${safeName}Tracker`);\n  const originalTarget = targetItemTracker.targetUuids.includes(lastArg.tokenUuid);\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTrackerFlag = DAE.getFlag(target, `${safeName}Tracker`);\n  const targetedThisCombat = targetTokenTrackerFlag && targetItemTracker.randomId === targetTokenTrackerFlag.randomId;\n  const targetTokenTracker = targetedThisCombat\n    ? targetTokenTrackerFlag\n    : {\n      randomId: targetItemTracker.randomId,\n      round: game.combat.round,\n      turn: game.combat.turn,\n      hasLeft: false,\n      condition: item.data.flags.ddbimporter.effect.condition,\n    };\n\n  const castTurn = targetItemTracker.startRound === game.combat.round && targetItemTracker.startTurn === game.combat.turn;\n  const isLaterTurn = game.combat.round > targetTokenTracker.round || game.combat.turn > targetTokenTracker.turn;\n  const everyEntry = hasProperty(item.data, \"flags.ddbimporter.effect.everyEntry\")\n    ? item.data.flags.ddbimporter.effect.everyEntry\n    : false;\n\n  // if:\n  // not cast turn, and not part of the original target\n  // AND one of the following\n  // not original template and have not yet had this effect applied this combat OR\n  // has been targeted this combat, left and re-entered effect, and is a later turn\n\n  if (castTurn && originalTarget) {\n    console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n  } else if (everyEntry || !targetedThisCombat || (targetedThisCombat && isLaterTurn)) {\n    console.debug(`Token ${target.name} is targeted for immediate save vs condition with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n    targetTokenTracker.hasLeft = false;\n    await applyCondition(targetTokenTracker.condition, target, item, targetItemTracker.spellLevel);\n  }\n  await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n  const allowVsRemoveCondition = item.data.flags.ddbimporter.effect.allowVsRemoveCondition;\n  const effectApplied = game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, target.document.uuid);\n  const currentTokenCombatTurn = game.combat.current.tokenId === lastArg.tokenId;\n  if (currentTokenCombatTurn && allowVsRemoveCondition && effectApplied) {\n    console.warn(`Removing ${targetTokenTracker.condition}`);\n    await attemptRemoval(target, targetTokenTracker.condition, item);\n  }\n} else if (args[0] == \"off\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const targetToken = await fromUuid(lastArg.tokenUuid);\n  const targetTokenTracker = await DAE.getFlag(targetToken, `${safeName}Tracker`);\n  const removeOnOff = hasProperty(lastArg, \"efData.flags.ddbimporter.effect.removeOnOff\")\n    ? lastArg.efData.flags.ddbimporter.effect.removeOnOff\n    : true;\n\n  if (targetTokenTracker?.condition && removeOnOff && game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, lastArg.tokenUuid)) {\n    console.debug(`Removing ${targetTokenTracker.condition} from ${targetToken.name}`);\n    game.dfreds.effectInterface.removeEffect({ effectName: targetTokenTracker.condition, uuid: lastArg.tokenUuid });\n  }\n\n  if (targetTokenTracker) {\n    targetTokenTracker.hasLeft = true;\n    targetTokenTracker.turn = game.combat.turn;\n    targetTokenTracker.round = game.combat.round;\n    await DAE.setFlag(targetToken, `${safeName}Tracker`, targetTokenTracker);\n  }\n}","folder":"lAtOjIPqjbuyD4E3","sort":0,"permission":{"default":0,"oU9dS4x0FAP6KDBX":3},"flags":{"advanced-macros":{"runAsGM":false}}}
{"name":"Eldritch Blast","type":"script","author":"NuvjPNM22yeczDUW","img":"systems/dnd5e/icons/spells/fireball-eerie-1.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Eldritch Blast\")","folder":null,"sort":0,"permission":{"default":0,"NuvjPNM22yeczDUW":3},"flags":{"dnd5e":{"itemMacro":true},"scene-packer":{"hash":"7b8951d83fb0e82ad3041a9de077e14e5a0f0ed8"}},"_id":"PRFwHIcgbURfdNwI"}
{"name":"Unarmed Strike","type":"script","author":"ceHDzkLi8PgIE5kO","img":"systems/dnd5e/icons/skills/yellow_08.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Unarmed Strike\")","folder":null,"sort":0,"permission":{"default":0,"ceHDzkLi8PgIE5kO":3},"flags":{"dnd5e":{"itemMacro":true},"scene-packer":{"hash":"e00ead8479da43316002b2e0b26985adc75c2cb9"}},"_id":"dHzrTwV2Zr7BAPEQ"}
{"name":"Unarmed Strike","type":"script","author":"9b3znrHgwdados9U","img":"systems/dnd5e/icons/skills/yellow_08.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Unarmed Strike\")","folder":null,"sort":0,"permission":{"default":0,"9b3znrHgwdados9U":3},"flags":{"dnd5e":{"itemMacro":true}},"_id":"eB21MaXgfjYyUiCk"}
{"name":"Word of Radiance","type":"script","author":"oU9dS4x0FAP6KDBX","img":"systems/dnd5e/icons/spells/air-burst-air-2.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Word of Radiance\")","folder":null,"sort":0,"permission":{"default":0,"oU9dS4x0FAP6KDBX":3},"flags":{"dnd5e":{"itemMacro":true}},"_id":"eE0Yo7C6Opep6XHQ"}
{"name":"Pass without Trace","type":"script","author":"NuvjPNM22yeczDUW","img":"systems/dnd5e/icons/spells/fog-air-1.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Pass without Trace\")","folder":null,"sort":0,"permission":{"default":0,"NuvjPNM22yeczDUW":3},"flags":{"dnd5e":{"itemMacro":true},"scene-packer":{"hash":"59f7d196200e569bb1cca6fc0e8d9e1fa27b130c"}},"_id":"fn6IEUJKUnXak5oN"}
{"name":"Dagger","type":"script","author":"0Dxn79T2d0e5V3LW","img":"icons/weapons/daggers/dagger-black.webp","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Dagger\")","folder":null,"sort":0,"permission":{"default":0,"0Dxn79T2d0e5V3LW":3},"flags":{"dnd5e":{"itemMacro":true}},"_id":"jzifYYs1KPvAltpl"}
{"_id":"ksVuWXANB3a731Hp","name":"Active Aura Damage and Condition On Entry (Generic)","type":"script","author":"oU9dS4x0FAP6KDBX","img":"icons/svg/dice-target.svg","scope":"global","command":"if(!game.modules.get(\"ActiveAuras\")?.active) {\n  ui.notifications.error(\"ActiveAuras is not enabled\");\n  return;\n}\n\nconst lastArg = args[args.length - 1];\n\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n\nfunction getHighestAbility(actor, abilities) {\n  if (typeof abilities === \"string\") {\n    return abilities;\n  } else if (Array.isArray(abilities)) {\n    return abilities.reduce((prv, current) => {\n      if (actor.data.abilities[current].value > actor.data.abilities[prv].value) return current;\n      else return prv;\n    }, abilities[0]);\n  }\n}\n\nfunction getCantripDice(actor) {\n  const level = actor.type === \"character\" ? actor.data.details.level : actor.data.details.cr;\n  return 1 + Math.floor((level + 1) / 6);\n}\n\n\nasync function attemptRemoval(targetToken, condition, item) {\n  if (game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    new Dialog({\n      title: `Use action to attempt to remove ${condition}?`,\n      buttons: {\n        one: {\n          label: \"Yes\",\n          callback: async () => {\n            const caster = item.parent;\n            const saveDc = caster.data.data.attributes.spelldc;\n            const removalCheck = item.data.flags.ddbimporter.effect.removalCheck;\n            const removalSave = item.data.flags.ddbimporter.effect.removalSave;\n            const ability = removalCheck ? getHighestAbility(targetToken.actor.data, removalCheck) : getHighestAbility(targetToken.actor.data, removalSave);\n            const type = removalCheck ? \"check\" : \"save\";\n            const flavor = `${condition} (via ${item.name}) : ${CONFIG.DND5E.abilities[ability]} ${type} vs DC${saveDc}`;\n            const rollResult = removalCheck\n              ? (await targetToken.actor.rollAbilityTest(ability, { flavor })).total\n              : (await targetToken.actor.rollAbilitySave(ability, { flavor })).total;\n\n            if (rollResult >= saveDc) {\n              game.dfreds.effectInterface.removeEffect({ effectName: condition, uuid: targetToken.document.uuid });\n            } else {\n              if (rollResult < saveDc) ChatMessage.create({ content: `${targetToken.name} fails the ${type} for ${item.name}, still has the ${condition} condition.` });\n            }\n          },\n        },\n        two: {\n          label: \"No\",\n          callback: () => {},\n        },\n      },\n    }).render(true);\n  }\n}\n\nasync function applyCondition(condition, targetToken, item, itemLevel) {\n  if (!game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    const caster = item.parent;\n    const workflowItemData = duplicate(item.data);\n    workflowItemData.data.target = { value: 1, units: \"\", type: \"creature\" };\n    workflowItemData.data.save.ability = item.data.flags.ddbimporter.effect.save;\n    workflowItemData.data.components.concentration = false;\n    workflowItemData.data.level = itemLevel;\n    workflowItemData.data.duration = { value: null, units: \"inst\" };\n    workflowItemData.data.target = { value: null, width: null, units: \"\", type: \"creature\" };\n    workflowItemData.data.preparation.mode = \"atwill\";\n    setProperty(workflowItemData, \"flags.itemacro\", {});\n    setProperty(workflowItemData, \"flags.midi-qol\", {});\n    setProperty(workflowItemData, \"flags.dae\", {});\n    setProperty(workflowItemData, \"effects\", []);\n    delete workflowItemData._id;\n    workflowItemData.name = `${workflowItemData.name}: ${item.name} Condition save`;\n    // console.warn(\"workflowItemData\", workflowItemData);\n\n    const saveTargets = [...game.user?.targets].map((t )=> t.id);\n    game.user.updateTokenTargets([targetToken.id]);\n    const saveItem = new CONFIG.Item.documentClass(workflowItemData, { parent: caster });\n    const options = { showFullCard: false, createWorkflow: true, configureDialog: true };\n    const result = await MidiQOL.completeItemRoll(saveItem, options);\n\n    game.user.updateTokenTargets(saveTargets);\n    const failedSaves = [...result.failedSaves];\n    if (failedSaves.length > 0) {\n      await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: failedSaves[0].document.uuid });\n    }\n\n    return result;\n  }\n}\n\nasync function attachSequencerFileToTemplate(templateUuid, sequencerFile, originUuid) {\n  if (game.modules.get(\"sequencer\")?.active) {\n    if (Sequencer.Database.entryExists(sequencerFile)) {\n      console.debug(`Trying to apply sequencer effect (${sequencerFile}) to ${templateUuid} from ${originUuid}`, sequencerFile);\n      const template = await fromUuid(templateUuid);\n      new Sequence()\n      .effect()\n        .file(Sequencer.Database.entryExists(sequencerFile))\n        .size({\n          width: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n          height: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n        })\n        .persist(true)\n        .origin(originUuid)\n        .belowTokens()\n        .opacity(0.5)\n        .attachTo(template, { followRotation: true })\n        .stretchTo(template, { attachTo: true})\n      .play();\n    }\n  }\n}\n\n\nasync function rollItemDamage(targetToken, itemUuid, itemLevel) {\n  const item = await fromUuid(itemUuid);\n  const caster = item.parent;\n  const isCantrip = item.data.flags.ddbimporter.effect.isCantrip;\n  const damageDice = item.data.flags.ddbimporter.effect.dice;\n  const damageType = item.data.flags.ddbimporter.effect.damageType;\n  const saveAbility = item.data.flags.ddbimporter.effect.save;\n  const casterToken = canvas.tokens.placeables.find((t) => t.actor?.uuid === caster.uuid);\n  const scalingDiceArray = item.data.data.scaling.formula.split(\"d\");\n  const scalingDiceNumber = itemLevel - item.data.data.level;\n  const upscaledDamage =  isCantrip\n    ? `${getCantripDice(caster.data)}d${scalingDiceArray[1]}[${damageType}]`\n    : scalingDiceNumber > 0 ? `${scalingDiceNumber}d${scalingDiceArray[1]}[${damageType}] + ${damageDice}` : damageDice;\n  const damageRoll = await new Roll(upscaledDamage).evaluate({ async: true });\n  if (game.dice3d) game.dice3d.showForRoll(damageRoll);\n  const workflowItemData = duplicate(item.data);\n  workflowItemData.data.target = { value: 1, units: \"\", type: \"creature\" };\n  workflowItemData.data.save.ability = saveAbility;\n  workflowItemData.data.components.concentration = false;\n  workflowItemData.data.level = itemLevel;\n  workflowItemData.data.duration = { value: null, units: \"inst\" };\n  workflowItemData.data.target = { value: null, width: null, units: \"\", type: \"creature\" };\n\n  setProperty(workflowItemData, \"flags.itemacro\", {});\n  setProperty(workflowItemData, \"flags.midi-qol\", {});\n  setProperty(workflowItemData, \"flags.dae\", {});\n  setProperty(workflowItemData, \"effects\", []);\n  delete workflowItemData._id;\n  workflowItemData.name = `${workflowItemData.name}: Turn Entry Damage`;\n  // console.warn(\"workflowItemData\", workflowItemData);\n\n  await new MidiQOL.DamageOnlyWorkflow(\n    caster,\n    casterToken.data,\n    damageRoll.total,\n    damageType,\n    [targetToken],\n    damageRoll,\n    {\n      flavor: `(${CONFIG.DND5E.damageTypes[damageType]})`,\n      itemCardId: \"new\",\n      itemData: workflowItemData,\n      isCritical: false,\n    }\n  );\n}\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preActiveEffects\") {\n  const safeName = lastArg.itemData.name.replace(/\\s|'|\\.|’/g, \"_\");\n  const dataTracker = {\n    randomId: randomID(),\n    targetUuids: lastArg.targetUuids,\n    startRound: game.combat.round,\n    startTurn: game.combat.turn,\n    spellLevel: lastArg.spellLevel,\n  };\n\n  const item = await fromUuid(lastArg.itemUuid);\n  // await item.update(dataTracker);\n  await DAE.unsetFlag(item, `${safeName}Tracker`);\n  await DAE.setFlag(item, `${safeName}Tracker`, dataTracker);\n\n  const ddbEffectFlags = lastArg.item.flags.ddbimporter?.effect;\n  const newArgs = duplicate(args);\n  if (ddbEffectFlags) {\n    const sequencerFile = ddbEffectFlags.sequencerFile;\n    if (sequencerFile) {\n      await attachSequencerFileToTemplate(lastArg.templateUuid, sequencerFile, lastArg.itemUuid)\n    }\n    if (ddbEffectFlags.isCantrip) {\n      const cantripDice = getCantripDice(lastArg.actor);\n      newArgs[0].spellLevel = cantripDice;\n      ddbEffectFlags.cantripDice = cantripDice;\n      let newEffects = newArgs[0].item.effects.map((effect) => {\n        effect.changes = effect.changes.map((change) => {\n          change.value = change.value.replace(\"@cantripDice\", cantripDice)\n          return change;\n        });\n        return effect;\n      });\n      newArgs[0].item.effects = duplicate(newEffects);\n      newArgs[0].itemData.effects = duplicate(newEffects);\n    }\n    const template = await fromUuid(lastArg.templateUuid);\n    await template.update({\"flags.effect\": ddbEffectFlags});\n\n    if (ddbEffectFlags.applyImmediate) {\n      console.debug(\"Applying immediate effect\");\n      await wait(500);\n      const condition = ddbEffectFlags.condition;\n      for (const token of lastArg.failedSaves) {\n        if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n          console.debug(`Applying ${condition} to ${token.name}`);\n          await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n        }\n      };\n    }\n  }\n\n  console.debug(\"ItemMacro: Pre-apply finised, applying effect to template\")\n\n  return await AAhelpers.applyTemplate(newArgs);\n\n} else if (args[0].tag === \"OnUse\" && args[0].macroPass === \"postActiveEffects\") {\n  if (lastArg.item.flags.ddbimporter?.effect?.applyImmediate) {\n    const condition = lastArg.item.flags.ddbimporter.effect.condition;\n    for (const token of lastArg.failedSaves) {\n      if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n        console.debug(`Applying ${condition} to ${token.name}`);\n        await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n      }\n    };\n  }\n} else if (args[0] == \"on\" || args[0] == \"each\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const item = await fromUuid(lastArg.efData.origin);\n  const ddbEffectFlags = item.data.flags.ddbimporter.effect;\n  // sometimes the round info has not updated, so we pause a bit\n  if (args[0] == \"each\") await wait(500);\n  const targetItemTracker = DAE.getFlag(item.parent, `${safeName}Tracker`);\n  const originalTarget = targetItemTracker.targetUuids.includes(lastArg.tokenUuid);\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTrackerFlag = DAE.getFlag(target, `${safeName}Tracker`);\n  const targetedThisCombat = targetTokenTrackerFlag && targetItemTracker.randomId === targetTokenTrackerFlag.randomId;\n  const targetTokenTracker = targetedThisCombat\n    ? targetTokenTrackerFlag\n    : {\n      randomId: targetItemTracker.randomId,\n      round: game.combat.round,\n      turn: game.combat.turn,\n      hasLeft: false,\n      condition: ddbEffectFlags.condition,\n    };\n\n  const castTurn = targetItemTracker.startRound === game.combat.round && targetItemTracker.startTurn === game.combat.turn;\n  const isLaterTurn = game.combat.round > targetTokenTracker.round || game.combat.turn > targetTokenTracker.turn;\n  const everyEntry = hasProperty(item.data, \"flags.ddbimporter.effect.everyEntry\")\n    ? item.data.flags.ddbimporter.effect.everyEntry\n    : false;\n\n  // if:\n  // not cast turn, and not part of the original target\n  // AND one of the following\n  // not original template and have not yet had this effect applied this combat OR\n  // has been targeted this combat, left and re-entered effect, and is a later turn\n\n  const autoDamageIfCondition = hasProperty(ddbEffectFlags, \"autoDamageIfCondition\") ? ddbEffectFlags.autoDamageIfCondition : false;\n  const hasConditionStart = game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, target.actor.uuid);\n  const applyAutoConditionDamage = autoDamageIfCondition && hasConditionStart;\n\n  if (ddbEffectFlags.conditionEffect && !hasConditionStart) {\n    if (castTurn && originalTarget) {\n      console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n    } else if (everyEntry || !targetedThisCombat || (targetedThisCombat && isLaterTurn)) {\n      console.debug(`Token ${target.name} is targeted for immediate save vs condition with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n      targetTokenTracker.hasLeft = false;\n      await applyCondition(targetTokenTracker.condition, target, item, targetItemTracker.spellLevel);\n    } else {\n      console.debug(`Token ${target.name} has not evaluated for condition application`);\n    }\n  }\n  if (ddbEffectFlags.damageEffect) {\n    if (castTurn && originalTarget) {\n      console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n    } else if ((!targetedThisCombat && !autoDamageIfCondition) || //if auto damage applied by conditional save\n      (targetedThisCombat && ((targetTokenTracker.hasLeft && isLaterTurn) || (applyAutoConditionDamage && isLaterTurn)))\n    ) {\n      console.debug(`Token ${target.name} is targeted for immediate damage with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n      targetTokenTracker.hasLeft = false;\n      await rollItemDamage(target, lastArg.efData.origin, targetItemTracker.spellLevel);\n    } else {\n      console.debug(`Token ${target.name} has not evaluated for damage application`);\n    }\n  }\n\n  targetTokenTracker.turn = game.combat.turn;\n  targetTokenTracker.round = game.combat.round;\n  await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n  const allowVsRemoveCondition = item.data.flags.ddbimporter.effect.allowVsRemoveCondition;\n  const hasConditionAppliedEnd = game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, target.document.uuid);\n  const currentTokenCombatTurn = game.combat.current.tokenId === lastArg.tokenId;\n  if (currentTokenCombatTurn && allowVsRemoveCondition && hasConditionAppliedEnd) {\n    console.warn(`Asking ${target.name} wants to remove ${targetTokenTracker.condition}`);\n    await attemptRemoval(target, targetTokenTracker.condition, item);\n  }\n} else if (args[0] == \"off\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const targetToken = await fromUuid(lastArg.tokenUuid);\n  const targetTokenTracker = await DAE.getFlag(targetToken, `${safeName}Tracker`);\n  const removeOnOff = hasProperty(lastArg, \"efData.flags.ddbimporter.effect.removeOnOff\")\n    ? lastArg.efData.flags.ddbimporter.effect.removeOnOff\n    : true;\n\n  if (targetTokenTracker?.condition && removeOnOff && game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, lastArg.tokenUuid)) {\n    console.debug(`Removing ${targetTokenTracker.condition} from ${targetToken.name}`);\n    game.dfreds.effectInterface.removeEffect({ effectName: targetTokenTracker.condition, uuid: lastArg.tokenUuid });\n  }\n\n  if (targetTokenTracker) {\n    targetTokenTracker.hasLeft = true;\n    await DAE.setFlag(targetToken, `${safeName}Tracker`, targetTokenTracker);\n  }\n}","folder":"lAtOjIPqjbuyD4E3","sort":0,"permission":{"default":0,"oU9dS4x0FAP6KDBX":3},"flags":{"advanced-macros":{"runAsGM":false}}}
{"_id":"lANWnkz7BO5B7fu7","name":"Active Aura Condition On Entry (Generic)","type":"script","author":"oU9dS4x0FAP6KDBX","img":"icons/svg/dice-target.svg","scope":"global","command":"if(!game.modules.get(\"ActiveAuras\")?.active) {\n  ui.notifications.error(\"ActiveAuras is not enabled\");\n  return;\n}\n\nconst lastArg = args[args.length - 1];\n\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n\nasync function attemptRemoval(targetToken, condition, item) {\n  if (game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    new Dialog({\n      title: `Use action to attempt to remove ${condition}?`,\n      buttons: {\n        one: {\n          label: \"Yes\",\n          callback: async () => {\n            const caster = item.parent;\n            const saveDc = caster.data.data.attributes.spelldc;\n            const removalCheck = item.data.flags.ddbimporter.effect.removalCheck;\n            const removalSave = item.data.flags.ddbimporter.effect.removalSave;\n            const ability = removalCheck ? removalCheck : removalSave;\n            const type = removalCheck ? \"check\" : \"save\";\n            const flavor = `${condition} (via ${item.name}) : ${CONFIG.DND5E.abilities[ability]} ${type} vs DC${saveDc}`;\n            const rollResult = removalCheck\n              ? (await targetToken.actor.rollAbilityTest(ability, { flavor })).total\n              : (await targetToken.actor.rollAbilitySave(ability, { flavor })).total;\n\n            if (rollResult >= saveDc) {\n              game.dfreds.effectInterface.removeEffect({ effectName: condition, uuid: targetToken.document.uuid });\n            } else {\n              if (rollResult < saveDc) ChatMessage.create({ content: `${targetToken.name} fails the ${type} for ${item.name}, still has the ${condition} condition.` });\n            }\n          },\n        },\n        two: {\n          label: \"No\",\n          callback: () => {},\n        },\n      },\n    }).render(true);\n  }\n}\n\nasync function applyCondition(condition, targetToken, item, itemLevel) {\n  if (!game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.document.uuid)) {\n    const caster = item.parent;\n    const workflowItemData = duplicate(item.data);\n    workflowItemData.data.target = { value: 1, units: \"\", type: \"creature\" };\n    workflowItemData.data.save.ability = item.data.flags.ddbimporter.effect.save;\n    workflowItemData.data.components.concentration = false;\n    workflowItemData.data.level = itemLevel;\n    workflowItemData.data.duration = { value: null, units: \"inst\" };\n    workflowItemData.data.target = { value: null, width: null, units: \"\", type: \"creature\" };\n    workflowItemData.data.preparation.mode = \"atwill\";\n    setProperty(workflowItemData, \"flags.itemacro\", {});\n    setProperty(workflowItemData, \"flags.midi-qol\", {});\n    setProperty(workflowItemData, \"flags.dae\", {});\n    setProperty(workflowItemData, \"effects\", []);\n    delete workflowItemData._id;\n    workflowItemData.name = `${workflowItemData.name}: ${item.name} Condition save`;\n    // console.warn(\"workflowItemData\", workflowItemData);\n\n    const saveTargets = [...game.user?.targets].map((t )=> t.id);\n    game.user.updateTokenTargets([targetToken.id]);\n    const saveItem = new CONFIG.Item.documentClass(workflowItemData, { parent: caster });\n    const options = { showFullCard: false, createWorkflow: true, configureDialog: true };\n    const result = await MidiQOL.completeItemRoll(saveItem, options);\n\n    game.user.updateTokenTargets(saveTargets);\n    const failedSaves = [...result.failedSaves];\n    if (failedSaves.length > 0) {\n      await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: failedSaves[0].document.uuid });\n    }\n\n    return result;\n  }\n}\n\nasync function attachSequencerFileToTemplate(templateUuid, sequencerFile, originUuid) {\n  if (game.modules.get(\"sequencer\")?.active) {\n    if (Sequencer.Database.entryExists(sequencerFile)) {\n      console.debug(`Trying to apply sequencer effect (${sequencerFile}) to ${templateUuid} from ${originUuid}`, sequencerFile);\n      const template = await fromUuid(templateUuid);\n      new Sequence()\n      .effect()\n        .file(Sequencer.Database.entryExists(sequencerFile))\n        .size({\n          width: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n          height: canvas.grid.size * (template.data.width / canvas.dimensions.distance),\n        })\n        .persist(true)\n        .origin(originUuid)\n        .belowTokens()\n        .opacity(0.5)\n        .attachTo(template, { followRotation: true })\n        .stretchTo(template, { attachTo: true})\n      .play();\n    }\n  }\n}\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preActiveEffects\") {\n  const safeName = lastArg.itemData.name.replace(/\\s|'|\\.|’/g, \"_\");\n  const dataTracker = {\n    randomId: randomID(),\n    targetUuids: lastArg.targetUuids,\n    startRound: game.combat.round,\n    startTurn: game.combat.turn,\n    spellLevel: lastArg.spellLevel,\n  };\n\n  const item = await fromUuid(lastArg.itemUuid);\n  // await item.update(dataTracker);\n  await DAE.unsetFlag(item, `${safeName}Tracker`);\n  await DAE.setFlag(item, `${safeName}Tracker`, dataTracker);\n\n  const sequencerFile = lastArg.item.flags.ddbimporter?.effect?.sequencerFile;\n  if (sequencerFile) {\n    attachSequencerFileToTemplate(lastArg.templateUuid, sequencerFile, lastArg.itemUuid)\n  }\n\n  if (lastArg.item.flags.ddbimporter?.effect?.applyImmediate) {\n    await wait(500);\n    const condition = lastArg.item.flags.ddbimporter.effect.condition;\n    for (const token of lastArg.failedSaves) {\n      if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n        console.debug(`Applying ${condition} to ${token.name}`);\n        await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n      }\n    };\n  }\n\n  return await AAhelpers.applyTemplate(args);\n\n} else if (args[0].tag === \"OnUse\" && args[0].macroPass === \"postActiveEffects\") {\n  if (lastArg.item.flags.ddbimporter?.effect?.applyImmediate) {\n    const condition = lastArg.item.flags.ddbimporter.effect.condition;\n    for (const token of lastArg.failedSaves) {\n      if (!game.dfreds.effectInterface.hasEffectApplied(condition, token.actor.uuid)) {\n        console.debug(`Applying ${condition} to ${token.name}`);\n        await game.dfreds.effectInterface.addEffect({ effectName: condition, uuid: token.actor.uuid });\n      }\n    };\n  }\n} else if (args[0] == \"on\" || args[0] == \"each\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const item = await fromUuid(lastArg.efData.origin);\n  // sometimes the round info has not updated, so we pause a bit\n  if (args[0] == \"each\") await wait(500);\n  const targetItemTracker = DAE.getFlag(item.parent, `${safeName}Tracker`);\n  const originalTarget = targetItemTracker.targetUuids.includes(lastArg.tokenUuid);\n  const target = canvas.tokens.get(lastArg.tokenId);\n  const targetTokenTrackerFlag = DAE.getFlag(target, `${safeName}Tracker`);\n  const targetedThisCombat = targetTokenTrackerFlag && targetItemTracker.randomId === targetTokenTrackerFlag.randomId;\n  const targetTokenTracker = targetedThisCombat\n    ? targetTokenTrackerFlag\n    : {\n      randomId: targetItemTracker.randomId,\n      round: game.combat.round,\n      turn: game.combat.turn,\n      hasLeft: false,\n      condition: item.data.flags.ddbimporter.effect.condition,\n    };\n\n  const castTurn = targetItemTracker.startRound === game.combat.round && targetItemTracker.startTurn === game.combat.turn;\n  const isLaterTurn = game.combat.round > targetTokenTracker.round || game.combat.turn > targetTokenTracker.turn;\n  const everyEntry = hasProperty(item.data, \"flags.ddbimporter.effect.everyEntry\")\n    ? item.data.flags.ddbimporter.effect.everyEntry\n    : false;\n\n  // if:\n  // not cast turn, and not part of the original target\n  // AND one of the following\n  // not original template and have not yet had this effect applied this combat OR\n  // has been targeted this combat, left and re-entered effect, and is a later turn\n\n  if (castTurn && originalTarget) {\n    console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n  } else if (everyEntry || !targetedThisCombat || (targetedThisCombat && isLaterTurn)) {\n    console.debug(`Token ${target.name} is targeted for immediate save vs condition with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n    targetTokenTracker.hasLeft = false;\n    await applyCondition(targetTokenTracker.condition, target, item, targetItemTracker.spellLevel);\n  }\n  await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n  const allowVsRemoveCondition = item.data.flags.ddbimporter.effect.allowVsRemoveCondition;\n  const effectApplied = game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, target.document.uuid);\n  const currentTokenCombatTurn = game.combat.current.tokenId === lastArg.tokenId;\n  if (currentTokenCombatTurn && allowVsRemoveCondition && effectApplied) {\n    console.warn(`Removing ${targetTokenTracker.condition}`);\n    await attemptRemoval(target, targetTokenTracker.condition, item);\n  }\n} else if (args[0] == \"off\") {\n  const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n  const targetToken = await fromUuid(lastArg.tokenUuid);\n  const targetTokenTracker = await DAE.getFlag(targetToken, `${safeName}Tracker`);\n  const removeOnOff = hasProperty(lastArg, \"efData.flags.ddbimporter.effect.removeOnOff\")\n    ? lastArg.efData.flags.ddbimporter.effect.removeOnOff\n    : true;\n\n  if (targetTokenTracker?.condition && removeOnOff && game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, lastArg.tokenUuid)) {\n    console.debug(`Removing ${targetTokenTracker.condition} from ${targetToken.name}`);\n    game.dfreds.effectInterface.removeEffect({ effectName: targetTokenTracker.condition, uuid: lastArg.tokenUuid });\n  }\n\n  if (targetTokenTracker) {\n    targetTokenTracker.hasLeft = true;\n    targetTokenTracker.turn = game.combat.turn;\n    targetTokenTracker.round = game.combat.round;\n    await DAE.setFlag(targetToken, `${safeName}Tracker`, targetTokenTracker);\n  }\n}","folder":"lAtOjIPqjbuyD4E3","sort":0,"permission":{"default":0,"oU9dS4x0FAP6KDBX":3},"flags":{"advanced-macros":{"runAsGM":false}}}
{"name":"Javelin of Rage","type":"script","author":"0Dxn79T2d0e5V3LW","img":"icons/weapons/polearms/javelin-simple.webp","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Javelin of Rage\")","folder":null,"sort":0,"permission":{"default":0,"0Dxn79T2d0e5V3LW":3},"flags":{"dnd5e":{"itemMacro":true}},"_id":"mjR5DZQ9onMvmUY8"}
{"name":"Longsword","type":"script","author":"NuvjPNM22yeczDUW","img":"systems/dnd5e/icons/items/weapons/sword-long.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Longsword\")","folder":null,"sort":0,"permission":{"default":0,"NuvjPNM22yeczDUW":3},"flags":{"dnd5e":{"itemMacro":true},"scene-packer":{"hash":"d33a18c42a6497d7500f9c30f5f0044c209dd795"}},"_id":"oa4094HXwROFAmBH"}
{"name":"Vicious Mockery","type":"script","author":"0Dxn79T2d0e5V3LW","img":"icons/magic/control/fear-fright-white.webp","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Vicious Mockery\")","folder":null,"sort":0,"permission":{"default":0,"0Dxn79T2d0e5V3LW":3},"flags":{"dnd5e":{"itemMacro":true}},"_id":"ouuVK8oQHQ0Xedh6"}
{"name":"Spear","type":"script","author":"ceHDzkLi8PgIE5kO","img":"systems/dnd5e/icons/items/weapons/spear.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Spear\")","folder":null,"sort":0,"permission":{"default":0,"ceHDzkLi8PgIE5kO":3},"flags":{"dnd5e":{"itemMacro":true},"scene-packer":{"hash":"c2ed011f68ceb4f74bc240182aec40fcde795bb2"}},"_id":"rZAgYfkdvsLPJkzm"}
{"_id":"uR9aYymgVRe5g1xK","name":"Darkness (DDB - GM)","type":"script","author":"oU9dS4x0FAP6KDBX","img":"systems/dnd5e/icons/skills/shadow_10.jpg","scope":"global","command":"// This Macro is called by the Darkness spell so players can place walls and lights.\n\nconst darknessParams = args[args.length - 1];\n\nfunction circleWall(cx, cy, radius) {\n  let walls = [];\n  const step = 30;\n  for (let i = step; i <= 360; i += step) {\n    let theta0 = Math.toRadians(i - step);\n    let theta1 = Math.toRadians(i);\n\n    let lastX = Math.floor(radius * Math.cos(theta0) + cx);\n    let lastY = Math.floor(radius * Math.sin(theta0) + cy);\n    let newX = Math.floor(radius * Math.cos(theta1) + cx);\n    let newY = Math.floor(radius * Math.sin(theta1) + cy);\n\n    walls.push({\n      c: [lastX, lastY, newX, newY],\n      move: CONST.WALL_MOVEMENT_TYPES.NONE,\n      light: CONST.WALL_SENSE_TYPES.NORMAL,\n      sight: CONST.WALL_SENSE_TYPES.NORMAL,\n      sound: CONST.WALL_SENSE_TYPES.NONE,\n      dir: CONST.WALL_DIRECTIONS.BOTH,\n      door: CONST.WALL_DOOR_TYPES.NONE,\n      ds: CONST.WALL_DOOR_STATES.CLOSED,\n      flags: {\n        spellEffects: {\n          Darkness: {\n            ActorId: darknessParams.targetActorId,\n          },\n        },\n      },\n    });\n  }\n\n  canvas.scene.createEmbeddedDocuments(\"Wall\", walls);\n}\n\nfunction darknessLight(cx, cy, radius) {\n  const lightTemplate = {\n    x: cx,\n    y: cy,\n    rotation: 0,\n    walls: false,\n    vision: false,\n    config: {\n      alpha: 0.5,\n      angle: 0,\n      bright: radius,\n      coloration: 1,\n      dim: 0,\n      gradual: false,\n      luminosity: -1,\n      saturation: 0,\n      contrast: 0,\n      shadows: 0,\n      animation: {\n        speed: 5,\n        intensity: 5,\n        reverse: false,\n      },\n      darkness: {\n        min: 0,\n        max: 1,\n      },\n      color: null,\n    },\n    hidden: false,\n    flags: {\n      spellEffects: {\n        Darkness: {\n          ActorId: darknessParams.targetActorId,\n        },\n      },\n      \"perfect-vision\": {\n        sightLimit: 0,\n      },\n    },\n  };\n  canvas.scene.createEmbeddedDocuments(\"AmbientLight\", [lightTemplate]);\n}\n\nif (args[0] == \"on\") {\n  if (!game.modules.get(\"perfect-vision\")?.active) circleWall(darknessParams.x, darknessParams.y, darknessParams.radius);\n  darknessLight(darknessParams.x, darknessParams.y, darknessParams.distance);\n}\n\nif (args[0] == \"off\") {\n  const darkWalls = canvas.walls.placeables.filter((w) => w.data.flags?.spellEffects?.Darkness?.ActorId === darknessParams.targetActorId);\n  const wallArray = darkWalls.map((w) => w.id);\n  const darkLights = canvas.lighting.placeables.filter((w) => w.data.flags?.spellEffects?.Darkness?.ActorId === darknessParams.targetActorId);\n  const lightArray = darkLights.map((w) => w.id);\n  await canvas.scene.deleteEmbeddedDocuments(\"Wall\", wallArray);\n  await canvas.scene.deleteEmbeddedDocuments(\"AmbientLight\", lightArray);\n}","folder":"lAtOjIPqjbuyD4E3","sort":0,"permission":{"default":0,"oU9dS4x0FAP6KDBX":3},"flags":{"advanced-macros":{"runAsGM":true}}}
{"name":"Expeditious Retreat","type":"script","author":"NuvjPNM22yeczDUW","img":"systems/dnd5e/icons/spells/haste-royal-2.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Expeditious Retreat\")","folder":null,"sort":0,"permission":{"default":0,"NuvjPNM22yeczDUW":3},"flags":{"dnd5e":{"itemMacro":true},"scene-packer":{"hash":"2f1e9b4c598c879f22a3a314fcea94ae5bfb6013"}},"_id":"upobVnjGFZmPQspN"}
{"name":"Toll the Dead","type":"script","author":"oU9dS4x0FAP6KDBX","img":"systems/dnd5e/icons/skills/water_03.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Toll the Dead\")","folder":null,"sort":0,"permission":{"default":0,"oU9dS4x0FAP6KDBX":3},"flags":{"dnd5e":{"itemMacro":true}},"_id":"vAFAuKUDG9F7SE7k"}
{"name":"Halberd","type":"script","author":"ceHDzkLi8PgIE5kO","img":"icons/weapons/polearms/halberd-crescent-small-spiked.webp","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Halberd\")","folder":null,"sort":0,"permission":{"default":0,"ceHDzkLi8PgIE5kO":3},"flags":{"dnd5e":{"itemMacro":true},"scene-packer":{"hash":"9aba2a5c0946a747e1af8e5a533189684aa81c00"}},"_id":"wIkgJr4zO39xK7O5"}
{"name":"New Macro","type":"chat","author":"NuvjPNM22yeczDUW","img":"icons/svg/dice-target.svg","scope":"global","command":"","folder":null,"sort":0,"permission":{"default":0,"NuvjPNM22yeczDUW":3},"flags":{},"_id":"xh8neLUEctoTT8Le"}
{"name":"New Macro","type":"chat","author":"n8QOlEn7xXUrcdjh","img":"icons/svg/dice-target.svg","scope":"global","command":"","folder":null,"sort":0,"permission":{"default":0,"n8QOlEn7xXUrcdjh":3},"flags":{"scene-packer":{"hash":"735d8ad2e80dbf0ce0fffc1b523d746c6b823f7d"}},"_id":"zQp6Nqa1AMw9Wgn1"}
{"name":"Inflict Wounds","type":"script","author":"oU9dS4x0FAP6KDBX","img":"systems/dnd5e/icons/spells/rip-jade-2.jpg","scope":"actor","command":"game.dnd5e.macros.rollItem(\"Inflict Wounds\")","folder":null,"sort":0,"permission":{"default":0,"oU9dS4x0FAP6KDBX":3},"flags":{"dnd5e":{"itemMacro":true}},"_id":"zpPvL2nUzkEuQ3oV"}
